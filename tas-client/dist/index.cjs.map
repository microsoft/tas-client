{
  "version": 3,
  "sources": ["../src/index.ts", "../src/tas-client/FeatureProvider/BaseFeatureProvider.ts", "../src/tas-client/FeatureProvider/FilteredFeatureProvider.ts", "../src/tas-client/FeatureProvider/TasApiFeatureProvider.ts", "../src/tas-client/Util/HttpClient.ts", "../src/tas-client/Util/MemoryKeyValueStorage.ts", "../src/tas-client/ExperimentationServiceBase.ts", "../src/tas-client/Util/PollingService.ts", "../src/tas-client/ExperimentationServiceAutoPolling.ts", "../src/tas-client/ExperimentationService.ts"],
  "sourcesContent": ["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport { IExperimentationFilterProvider } from './contracts/IExperimentationFilterProvider.js';\nexport { IExperimentationService } from './contracts/IExperimentationService.js';\nexport { IExperimentationTelemetry } from './contracts/IExperimentationTelemetry.js';\nexport { IKeyValueStorage } from './contracts/IKeyValueStorage.js';\nexport { ExperimentationService } from './tas-client/ExperimentationService.js';\nexport { ExperimentationServiceConfig } from './contracts/ExperimentationServiceConfig.js';\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IFeatureProvider, FeatureData } from './IFeatureProvider.js';\nimport { IExperimentationTelemetry } from 'src/contracts/IExperimentationTelemetry.js';\n\n/**\n * Abstract class for Feature Provider Implementation.\n */\nexport abstract class BaseFeatureProvider implements IFeatureProvider {\n    private fetchPromise?: Promise<FeatureData>;\n    private isFetching: boolean = false;\n\n    /**\n     * @param telemetry The telemetry implementation.\n     */\n    constructor(protected telemetry: IExperimentationTelemetry) {}\n\n    /**\n     * Method that wraps the fetch method in order to re-use the fetch promise if needed.\n     * @param headers The headers to be used on the fetch method.\n     */\n    public async getFeatures(): Promise<FeatureData> {\n        if (this.isFetching && this.fetchPromise) {\n            return this.fetchPromise;\n        }\n\n        this.fetchPromise = this.fetch();\n        let features = await this.fetchPromise;\n        this.isFetching = false;\n        this.fetchPromise = undefined;\n\n        return features;\n    }\n\n    /**\n     * Fetch method that retrieves asynchronously the required feature data.\n     */\n    protected abstract fetch(): Promise<FeatureData>;\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IExperimentationFilterProvider } from '../../contracts/IExperimentationFilterProvider.js';\nimport { BaseFeatureProvider } from './BaseFeatureProvider.js';\nimport { IExperimentationTelemetry } from '../../contracts/IExperimentationTelemetry.js';\n\n/**\n * Feature provider implementation that handles filters.\n */\nexport abstract class FilteredFeatureProvider extends BaseFeatureProvider {\n    constructor(\n        protected telemetry: IExperimentationTelemetry,\n        protected filterProviders: IExperimentationFilterProvider[],\n    ) {\n        super(telemetry);\n    }\n\n    private cachedTelemetryEvents: any[] = [];\n\n    protected getFilters(): Map<string, any> {\n        // We get the filters that will be sent as headers.\n        let filters: Map<string, any> = new Map<string, any>();\n        for (let filter of this.filterProviders) {\n            let filterHeaders = filter.getFilters();\n            for (let key of filterHeaders.keys()) {\n                // Headers can be overridden by custom filters.\n                // That's why a check isn't done to see if the header already exists, the value is just set.\n                let filterValue = filterHeaders.get(key);\n                filters.set(key, filterValue);\n            }\n        }\n        return filters;\n    }\n\n    protected PostEventToTelemetry(headers: any) {\n        /**\n         * If these headers have already been posted, we skip from posting them again..\n         */\n        if (this.cachedTelemetryEvents.includes(headers)) {\n            return;\n        }\n\n        const jsonHeaders = JSON.stringify(headers);\n\n        this.telemetry.postEvent(\n            'report-headers',\n            new Map<string, string>([['ABExp.headers', jsonHeaders]]),\n        );\n\n        /**\n         * We cache the flight so we don't post it again.\n         */\n        this.cachedTelemetryEvents.push(headers);\n    }\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IExperimentationFilterProvider } from '../../contracts/IExperimentationFilterProvider.js';\nimport { FetchError, FetchResult, HttpClient } from '../Util/HttpClient.js';\nimport { IExperimentationTelemetry } from '../../contracts/IExperimentationTelemetry.js';\nimport { FilteredFeatureProvider } from './FilteredFeatureProvider.js';\nimport { FeatureData, ConfigData } from './IFeatureProvider.js';\n\nexport const TASAPI_FETCHERROR_EVENTNAME = 'call-tas-error';\nconst ERROR_TYPE = 'ErrorType';\n/**\n * Feature provider implementation that calls the TAS web service to get the most recent active features.\n */\nexport class TasApiFeatureProvider extends FilteredFeatureProvider {\n    constructor(\n        protected httpClient: HttpClient,\n        protected telemetry: IExperimentationTelemetry,\n        protected filterProviders: IExperimentationFilterProvider[],\n    ) {\n        super(telemetry, filterProviders);\n    }\n\n    /**\n     * Method that handles fetching of latest data (in this case, flights) from the provider.\n     */\n    public async fetch(): Promise<FeatureData> {\n        // We get the filters that will be sent as headers.\n        let filters = this.getFilters();\n        let headers: any = {};\n\n        // Filters are handled using Map<string,any> therefore we need to\n        // convert these filters into something fetch can take as headers.\n        for (let key of filters.keys()) {\n            const filterValue = filters.get(key);\n            headers[key] = filterValue;\n        }\n\n        //webservice call\n        let response: FetchResult | undefined;\n\n        try {\n            response = await this.httpClient.get({ headers: headers });\n        } catch (error) {\n            const fetchError = error as FetchError;\n            const properties: Map<string, string> = new Map();\n            if (fetchError.responseReceived && !fetchError.responseOk) {\n                // The request was made and the server responded with a status code\n                // that falls out of the range of 2xx\n                properties.set(ERROR_TYPE, 'ServerError');\n            } else if (fetchError.responseReceived === false) {\n                // The request was made but no response was received\n                properties.set(ERROR_TYPE, 'NoResponse');\n            } else {\n                // Something happened in setting up the request that triggered an Error\n                properties.set(ERROR_TYPE, 'GenericError');\n            }\n            this.telemetry.postEvent(TASAPI_FETCHERROR_EVENTNAME, properties);\n        }\n\n        // In case the response fetching failed, throw\n        // exception so that the caller exits.\n        if (!response) {\n            throw Error(TASAPI_FETCHERROR_EVENTNAME);\n        }\n\n        // If we have at least one filter, we post it to telemetry event.\n        if (filters.keys.length > 0) {\n            this.PostEventToTelemetry(headers);\n        }\n\n        // Read the response data from the server.\n        const responseData = response.data;\n        let configs = responseData.Configs;\n        let features: string[] = [];\n        for (let c of configs) {\n            if (!c.Parameters) {\n                continue;\n            }\n\n            for (let key of Object.keys(c.Parameters)) {\n                const featureName = key + (c.Parameters[key] ? '' : 'cf');\n                if (!features.includes(featureName)) {\n                    features.push(featureName);\n                }\n            }\n        }\n\n        return {\n            features,\n            assignmentContext: responseData.AssignmentContext,\n            configs,\n        };\n    }\n}\n\nexport interface TASFeatureData {\n    Features: any[];\n    Flights: any[];\n    Configs: ConfigData[];\n    ParameterGroups: any[];\n    FlightingVersion: number;\n    ImpressionId: string;\n    FlightingEnrichments: any;\n    AssignmentContext: string;\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport interface RequestConfig {\n    headers?: Record<string, string>;\n}\n\nexport interface FetchResult {\n    data: any;\n}\n\nexport class FetchError extends Error {\n    constructor(\n        message: string,\n        public readonly responseReceived?: boolean,\n        public readonly responseOk?: boolean,\n    ) {\n        super(message);\n    }\n}\n\nexport class HttpClient {\n    constructor(\n        private endpoint: string,\n        private useNodeModules = typeof process !== 'undefined' && !!process.versions.node,\n    ) {}\n\n    public async get(config?: RequestConfig | undefined): Promise<FetchResult> {\n        if (this.useNodeModules) {\n            return this.nodeGet(config);\n        } else {\n            return this.webGet(config);\n        }\n    }\n\n    private async nodeGet(config?: RequestConfig | undefined): Promise<FetchResult> {\n        const http = await import('http');\n        const https = await import('https');\n        return new Promise<FetchResult>((resolve, reject) => {\n            const req = (this.endpoint.startsWith('http:') ? http : https).get(\n                this.endpoint,\n                config || {},\n                (res) => {\n                    if (res.statusCode! < 200 || res.statusCode! > 299) {\n                        reject(new FetchError('Response not ok', true, false));\n                    } else {\n                        res.on('error', reject);\n                        const chunks: Buffer[] = [];\n                        res.on('data', (chunk) => chunks.push(chunk));\n                        res.on('end', () => {\n                            try {\n                                const data = JSON.parse(Buffer.concat(chunks).toString());\n                                if (!data) {\n                                    reject(new FetchError('No data received', false));\n                                } else {\n                                    resolve({ data });\n                                }\n                            } catch (err) {\n                                reject(err);\n                            }\n                        });\n                    }\n                },\n            );\n            req.on('error', reject);\n            req.end();\n        });\n    }\n\n    private async webGet(config?: RequestConfig | undefined): Promise<FetchResult> {\n        const response = await fetch(this.endpoint, {\n            method: 'GET',\n            headers: config?.headers,\n        });\n\n        if (!response) {\n            throw new FetchError('No response received', false);\n        }\n\n        if (!response.ok) {\n            throw new FetchError('Response not ok', true, false);\n        }\n\n        const data = await response.json();\n        if (!data) {\n            throw new FetchError('No data received', false);\n        }\n        return { data };\n    }\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IKeyValueStorage } from '../../contracts/IKeyValueStorage.js';\nexport class MemoryKeyValueStorage implements IKeyValueStorage {\n    private storage: Map<string, any> = new Map<string, any>();\n\n    public async getValue<T>(key: string, defaultValue?: T): Promise<T | undefined> {\n        if (this.storage.has(key)) {\n            return await Promise.resolve(this.storage.get(key));\n        }\n\n        return await Promise.resolve(defaultValue || undefined);\n    }\n\n    public setValue<T>(key: string, value: T): void {\n        this.storage.set(key, value);\n    }\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IExperimentationService } from '../contracts/IExperimentationService.js';\nimport { IExperimentationTelemetry } from '../contracts/IExperimentationTelemetry.js';\nimport { IKeyValueStorage } from '../contracts/IKeyValueStorage.js';\nimport { IFeatureProvider, FeatureData } from './FeatureProvider/IFeatureProvider.js';\nimport { MemoryKeyValueStorage } from './Util/MemoryKeyValueStorage.js';\n\n/**\n * Experimentation service to provide functionality of A/B experiments:\n * - reading flights;\n * - caching current set of flights;\n * - get answer on if flights are enabled.\n */\nexport abstract class ExperimentationServiceBase implements IExperimentationService {\n    protected featureProviders?: IFeatureProvider[];\n    protected fetchPromise?: Promise<FeatureData[]>;\n    protected featuresConsumed = false;\n    private loadCachePromise: Promise<void>;\n    public readonly initializePromise: Promise<void>;\n    private resolveInitialFetchPromise: (() => void) | undefined;\n    public readonly initialFetch: Promise<void>;\n\n    private cachedTelemetryEvents: string[] = [];\n    private _features: FeatureData = {\n        features: [],\n        assignmentContext: '',\n        configs: [],\n    };\n    private get features(): FeatureData {\n        return this._features;\n    }\n    private set features(value: FeatureData) {\n        this._features = value;\n        /**\n         * If an implementation of telemetry exists, we set the shared property.\n         */\n        if (this.telemetry) {\n            this.telemetry.setSharedProperty(\n                this.assignmentContextTelemetryPropertyName,\n                this.features.assignmentContext,\n            );\n        }\n    }\n\n    constructor(\n        protected telemetry: IExperimentationTelemetry,\n        protected assignmentContextTelemetryPropertyName: string,\n        protected telemetryEventName: string,\n        protected storageKey?: string,\n        protected storage?: IKeyValueStorage,\n    ) {\n        if (!this.storageKey) {\n            this.storageKey = 'ABExp.Features';\n        }\n\n        if (!this.storage) {\n            storage = new MemoryKeyValueStorage();\n        }\n\n        this.loadCachePromise = this.loadCachedFeatureData();\n        this.initializePromise = this.loadCachePromise;\n        this.initialFetch = new Promise<void>((resolve, reject) => {\n            this.resolveInitialFetchPromise = resolve;\n        });\n    }\n\n    /**\n     * Gets all the features from the provider sources (not cache).\n     * It returns these features and will also update the providers to have the latest features cached.\n     */\n    protected async getFeaturesAsync(overrideInMemoryFeatures = false): Promise<FeatureData> {\n        /**\n         * If there's already a fetching promise, there's no need to call it again.\n         * We return that as result.\n         */\n        if (this.fetchPromise != null) {\n            try {\n                await this.fetchPromise;\n            } catch {\n                // Fetching features threw. Can happen if not connected to the internet, e.g\n            }\n            return this.features;\n        }\n\n        if (!this.featureProviders || this.featureProviders.length === 0) {\n            return Promise.resolve({\n                features: [],\n                assignmentContext: '',\n                configs: [],\n            });\n        }\n\n        try {\n            /**\n             * Fetch all from providers.\n             */\n            this.fetchPromise = Promise.all(\n                this.featureProviders.map(async (provider) => {\n                    return await provider.getFeatures();\n                }),\n            );\n            const featureResults = await this.fetchPromise;\n            this.updateFeatures(featureResults, overrideInMemoryFeatures);\n        } catch {\n            // Fetching features threw error. Can happen if not connected to the internet, e.g.\n        }\n\n        this.fetchPromise = undefined;\n\n        if (this.resolveInitialFetchPromise) {\n            this.resolveInitialFetchPromise();\n            this.resolveInitialFetchPromise = undefined;\n        }\n\n        /**\n         * At this point all features have been re-fetched and cache has been updated.\n         * We return the cached features.\n         */\n        return this.features;\n    }\n\n    /**\n     *\n     * @param featureResults The feature results obtained from all the feature providers.\n     */\n    protected updateFeatures(featureResults: FeatureData[], overrideInMemoryFeatures = false) {\n        /**\n         * if features comes as a null value, that is taken as if there aren't any features active,\n         * so an empty array is defaulted.\n         */\n        let features: FeatureData = {\n            features: [],\n            assignmentContext: '',\n            configs: [],\n        };\n\n        for (let result of featureResults) {\n            for (let feature of result.features) {\n                if (!features.features.includes(feature)) {\n                    features.features.push(feature);\n                }\n            }\n            for (let config of result.configs) {\n                const existingConfig = features.configs.find((c) => c.Id === config.Id);\n                if (existingConfig) {\n                    existingConfig.Parameters = {\n                        ...existingConfig.Parameters,\n                        ...config.Parameters,\n                    };\n                } else {\n                    features.configs.push(config);\n                }\n            }\n            features.assignmentContext += result.assignmentContext;\n        }\n\n        /**\n         * Set the obtained feature values to the global features variable. This stores them in memory.\n         */\n        if (overrideInMemoryFeatures || !this.featuresConsumed) {\n            this.features = features;\n        }\n\n        /**\n         * If we have storage, we cache the latest results into the storage.\n         */\n        if (this.storage) {\n            this.storage.setValue<FeatureData>(this.storageKey!, features);\n        }\n    }\n\n    private async loadCachedFeatureData() {\n        let cachedFeatureData: FeatureData | undefined;\n        if (this.storage) {\n            cachedFeatureData = await this.storage.getValue<FeatureData>(this.storageKey!);\n            // When updating from an older version of tas-client, configs may be undefined\n            if (cachedFeatureData !== undefined && cachedFeatureData.configs === undefined) {\n                cachedFeatureData.configs = [];\n            }\n        }\n        if (this.features.features.length === 0) {\n            this.features = cachedFeatureData || {\n                features: [],\n                assignmentContext: '',\n                configs: [],\n            };\n        }\n    }\n\n    /**\n     * Returns a value indicating whether the given flight is enabled.\n     * It uses the in-memory cache.\n     * @param flight The flight to check.\n     */\n    public isFlightEnabled(flight: string): boolean {\n        this.featuresConsumed = true;\n        this.PostEventToTelemetry(flight);\n        return this.features.features.includes(flight);\n    }\n\n    /**\n     * Returns a value indicating whether the given flight is enabled.\n     * It uses the values currently on cache.\n     * @param flight The flight to check.\n     */\n    public async isCachedFlightEnabled(flight: string): Promise<boolean> {\n        await this.loadCachePromise;\n        this.featuresConsumed = true;\n        this.PostEventToTelemetry(flight);\n        return this.features.features.includes(flight);\n    }\n\n    /**\n     * Returns a value indicating whether the given flight is enabled.\n     * It re-fetches values from the server.\n     * @param flight the flight to check.\n     */\n    public async isFlightEnabledAsync(flight: string): Promise<boolean> {\n        const features = await this.getFeaturesAsync(true);\n        this.featuresConsumed = true;\n        this.PostEventToTelemetry(flight);\n        return features.features.includes(flight);\n    }\n\n    /**\n     * Returns the value of the treatment variable, or undefined if not found.\n     * It uses the values currently in memory, so the experimentation service\n     * must be initialized before calling.\n     * @param config name of the config to check.\n     * @param name name of the treatment variable.\n     */\n    public getTreatmentVariable<T extends boolean | number | string>(\n        configId: string,\n        name: string,\n    ): T | undefined {\n        this.featuresConsumed = true;\n        this.PostEventToTelemetry(`${configId}.${name}`);\n        const config = this.features.configs.find((c) => c.Id === configId);\n        return config?.Parameters[name] as T;\n    }\n\n    /**\n     * Returns the value of the treatment variable, or undefined if not found.\n     * It re-fetches values from the server. If checkCache is set to true and the value exists\n     * in the cache, the Treatment Assignment Service is not called.\n     * @param config name of the config to check.\n     * @param name name of the treatment variable.\n     * @param checkCache check the cache for the variable before calling the TAS.\n     */\n    public async getTreatmentVariableAsync<T extends boolean | number | string>(\n        configId: string,\n        name: string,\n        checkCache?: boolean,\n    ): Promise<T | undefined> {\n        if (checkCache) {\n            const _featuresConsumed = this.featuresConsumed;\n            const cachedValue = this.getTreatmentVariable<T>(configId, name);\n            if (cachedValue === undefined) {\n                this.featuresConsumed = _featuresConsumed;\n            } else {\n                return cachedValue;\n            }\n        }\n        await this.getFeaturesAsync(true);\n        return this.getTreatmentVariable<T>(configId, name);\n    }\n\n    private PostEventToTelemetry(flight: string): void {\n        /**\n         * If this event has already been posted, we omit from posting it again.\n         */\n        if (this.cachedTelemetryEvents.includes(flight)) {\n            return;\n        }\n        this.telemetry.postEvent(\n            this.telemetryEventName,\n            new Map<string, string>([['ABExp.queriedFeature', flight]]),\n        );\n\n        /**\n         * We cache the flight so we don't post it again.\n         */\n        this.cachedTelemetryEvents.push(flight);\n    }\n\n    protected invokeInit(): void {\n        this.init();\n    }\n\n    /**\n     * Method to do any post-base constructor calls.\n     * Consider this a constructor for the derived classes.\n     * Can be used to initialize the Feature Providers.\n     * No async calls should be done here.\n     */\n    protected abstract init(): void;\n\n    protected addFeatureProvider(...providers: IFeatureProvider[]) {\n        if (providers == null || this.featureProviders == null) {\n            return;\n        }\n        for (let provider of providers) {\n            this.featureProviders!.push(provider);\n        }\n    }\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nexport class PollingService {\n    private intervalHandle?: any;\n    public onTick: (() => Promise<void>) | undefined;\n\n    constructor(private fetchInterval: number) {}\n\n    public StopPolling(): void {\n        clearInterval(this.intervalHandle);\n        this.intervalHandle = undefined;\n    }\n\n    public OnPollTick(callback: () => Promise<void>) {\n        this.onTick = callback;\n    }\n\n    public StartPolling(pollImmediately = false) {\n        if (this.intervalHandle) {\n            this.StopPolling();\n        }\n\n        // If there's no callback, there's no point to start polling.\n        if (this.onTick == null) {\n            return;\n        }\n\n        if (pollImmediately) {\n            this.onTick!()\n                .then(() => {\n                    return;\n                })\n                .catch(() => {\n                    return;\n                });\n        }\n\n        /**\n         * Set the interval to start running.\n         */\n        this.intervalHandle = setInterval(async () => {\n            await this.onTick!();\n        }, this.fetchInterval);\n        if (this.intervalHandle.unref) {\n            // unref is only available in Node, not the web\n            this.intervalHandle.unref(); // unref is used to avoid keeping node.js alive only because of these timeouts.\n        }\n    }\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { ExperimentationServiceBase } from './ExperimentationServiceBase.js';\nimport { IExperimentationTelemetry } from '../contracts/IExperimentationTelemetry.js';\nimport { PollingService } from './Util/PollingService.js';\nimport { IExperimentationFilterProvider } from '../contracts/IExperimentationFilterProvider.js';\nimport { IKeyValueStorage } from '../contracts/IKeyValueStorage.js';\nimport { FeatureData } from './FeatureProvider/IFeatureProvider.js';\n\n/**\n * Implementation of Feature provider that provides a polling feature, where the source can be re-fetched every x time given.\n */\nexport abstract class ExperimentationServiceAutoPolling extends ExperimentationServiceBase {\n    private pollingService?: PollingService;\n\n    constructor(\n        protected telemetry: IExperimentationTelemetry,\n        protected filterProviders: IExperimentationFilterProvider[],\n        protected refreshRateMs: number,\n        protected assignmentContextTelemetryPropertyName: string,\n        protected telemetryEventName: string,\n        protected storageKey?: string,\n        protected storage?: IKeyValueStorage,\n    ) {\n        super(\n            telemetry,\n            assignmentContextTelemetryPropertyName,\n            telemetryEventName,\n            storageKey,\n            storage,\n        );\n        // Excluding 0 since it allows to turn off the auto polling.\n        if (refreshRateMs < 1000 && refreshRateMs !== 0) {\n            throw new Error(\n                'The minimum refresh rate for polling is 1000 ms (1 second). If you wish to deactivate this auto-polling use value of 0.',\n            );\n        }\n\n        if (refreshRateMs > 0) {\n            this.pollingService = new PollingService(refreshRateMs);\n            this.pollingService.OnPollTick(async () => {\n                await super.getFeaturesAsync();\n            });\n        }\n    }\n\n    protected init(): void {\n        if (this.pollingService) {\n            this.pollingService.StartPolling(true);\n        } else {\n            super.getFeaturesAsync();\n        }\n    }\n\n    /**\n     * Wrapper that will reset the polling intervals whenever the feature data is fetched manually.\n     */\n    protected async getFeaturesAsync(overrideInMemoryFeatures = false): Promise<FeatureData> {\n        if (!this.pollingService) {\n            return await super.getFeaturesAsync(overrideInMemoryFeatures);\n        } else {\n            this.pollingService.StopPolling();\n            let result = await super.getFeaturesAsync(overrideInMemoryFeatures);\n            this.pollingService.StartPolling();\n            return result;\n        }\n    }\n}\n", "/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\nimport { IFeatureProvider } from './FeatureProvider/IFeatureProvider.js';\nimport { TasApiFeatureProvider } from './FeatureProvider/TasApiFeatureProvider.js';\nimport { HttpClient } from './Util/HttpClient.js';\nimport { ExperimentationServiceConfig } from '../contracts/ExperimentationServiceConfig.js';\nimport { ExperimentationServiceAutoPolling } from './ExperimentationServiceAutoPolling.js';\n\n/**\n * Experimentation service to provide functionality of A/B experiments:\n * - reading flights;\n * - caching current set of flights;\n * - get answer on if flights are enabled.\n */\nexport class ExperimentationService extends ExperimentationServiceAutoPolling {\n    public static REFRESH_RATE_IN_MINUTES: number = 30;\n\n    constructor(private options: ExperimentationServiceConfig) {\n        super(\n            options.telemetry,\n            options.filterProviders || [], // Defaulted to empty array.\n            options.refetchInterval != null\n                ? options.refetchInterval\n                : // If no fetch interval is provided, refetch functionality is turned off.\n                  0,\n            options.assignmentContextTelemetryPropertyName,\n            options.telemetryEventName,\n            options.storageKey,\n            options.keyValueStorage,\n        );\n        this.invokeInit();\n    }\n\n    protected init(): void {\n        // set feature providers to be an empty array.\n        this.featureProviders = [];\n\n        // Add WebApi feature provider.\n        this.addFeatureProvider(\n            new TasApiFeatureProvider(\n                new HttpClient(this.options.endpoint),\n                this.telemetry,\n                this.filterProviders,\n            ),\n        );\n\n        // This will start polling the TAS.\n        super.init();\n    }\n}\n"],
  "mappings": "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",
  "names": []
}
